(window.webpackJsonp=window.webpackJsonp||[]).push([[140],{620:function(_,v,e){"use strict";e.r(v);var o=e(32),t=Object(o.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h2",{attrs:{id:"elasticsearch-原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#elasticsearch-原理"}},[_._v("#")]),_._v(" ElasticSearch 原理")]),_._v(" "),e("p",[_._v("ES写数据过程:")]),_._v(" "),e("ul",[e("li",[_._v("客户端选择一个 node 发送请求过去，这个 node 就是 "),e("code",[_._v("coordinating node")]),_._v("（协调节点）。")]),_._v(" "),e("li",[e("code",[_._v("coordinating node")]),_._v(" 对 document 进行"),e("strong",[_._v("路由")]),_._v("，将请求转发给对应的 node（有 primary shard）。")]),_._v(" "),e("li",[_._v("实际的 node 上的 "),e("code",[_._v("primary shard")]),_._v(" 处理请求，然后将数据同步到 "),e("code",[_._v("replica node")]),_._v("。")]),_._v(" "),e("li",[e("code",[_._v("coordinating node")]),_._v(" 如果发现 "),e("code",[_._v("primary node")]),_._v(" 和所有 "),e("code",[_._v("replica node")]),_._v(" 都搞定之后，就返回响应结果给客户端。")])]),_._v(" "),e("h3",{attrs:{id:"_1-2-es读数据过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-es读数据过程"}},[_._v("#")]),_._v(" 1.2 ES读数据过程")]),_._v(" "),e("p",[_._v("可以通过 "),e("code",[_._v("doc id")]),_._v(" 来查询，会根据 "),e("code",[_._v("doc id")]),_._v(" 进行 hash，判断出来当时把 "),e("code",[_._v("doc id")]),_._v(" 分配到了哪个 shard 上面去，从那个 shard 去查询。")]),_._v(" "),e("ul",[e("li",[_._v("客户端发送请求到"),e("strong",[_._v("任意")]),_._v("一个 node，成为 "),e("code",[_._v("coordinate node")]),_._v("。")]),_._v(" "),e("li",[e("code",[_._v("coordinate node")]),_._v(" 对 "),e("code",[_._v("doc id")]),_._v(" 进行哈希路由，将请求转发到对应的 node，此时会使用 "),e("code",[_._v("round-robin")]),_._v(" "),e("strong",[_._v("随机轮询算法")]),_._v("，在 "),e("code",[_._v("primary shard")]),_._v(" 以及其所有 replica 中随机选择一个，让读请求负载均衡。")]),_._v(" "),e("li",[_._v("接收请求的 node 返回 document 给 "),e("code",[_._v("coordinate node")]),_._v("。")]),_._v(" "),e("li",[e("code",[_._v("coordinate node")]),_._v(" 返回 document 给客户端。")])]),_._v(" "),e("h3",{attrs:{id:"_1-3-es写数据底层原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-es写数据底层原理"}},[_._v("#")]),_._v(" 1.3 ES写数据底层原理")]),_._v(" "),e("p",[_._v("先写入内存 buffer，在 buffer 里的时候数据是搜索不到的；同时将数据写入 translog 日志文件。")]),_._v(" "),e("p",[_._v("如果 buffer 快满了，或者到一定时间，就会将内存 buffer 数据 "),e("code",[_._v("refresh")]),_._v(" 到一个新的 "),e("code",[_._v("segment file")]),_._v(" 中，但是此时数据不是直接进入 "),e("code",[_._v("segment file")]),_._v(" 磁盘文件，而是先进入 "),e("code",[_._v("os cache")]),_._v(" 。这个过程就是 "),e("code",[_._v("refresh")]),_._v("。")]),_._v(" "),e("p",[_._v("每隔 1 秒钟，es 将 buffer 中的数据写入一个"),e("strong",[_._v("新的")]),_._v(" "),e("code",[_._v("segment file")]),_._v("，每秒钟会产生一个"),e("strong",[_._v("新的磁盘文件")]),_._v(" "),e("code",[_._v("segment file")]),_._v("，这个 "),e("code",[_._v("segment file")]),_._v(" 中就存储最近 1 秒内 buffer 中写入的数据。")]),_._v(" "),e("p",[_._v("但是如果 buffer 里面此时没有数据，那当然不会执行 refresh 操作，如果 buffer 里面有数据，默认 1 秒钟执行一次 refresh 操作，刷入一个新的 segment file 中。")]),_._v(" "),e("p",[_._v("操作系统里面，磁盘文件其实都有一个东西，叫做 "),e("code",[_._v("os cache")]),_._v("，即操作系统缓存，就是说数据写入磁盘文件之前，会先进入 "),e("code",[_._v("os cache")]),_._v("，先进入操作系统级别的一个内存缓存中去。只要 "),e("code",[_._v("buffer")]),_._v(" 中的数据被 refresh 操作刷入 "),e("code",[_._v("os cache")]),_._v("中，这个数据就可以被搜索到了。")]),_._v(" "),e("p",[_._v("为什么叫 es 是"),e("strong",[_._v("准实时")]),_._v("的？ "),e("code",[_._v("NRT")]),_._v("，全称 "),e("code",[_._v("near real-time")]),_._v("。默认是每隔 1 秒 refresh 一次的，所以 es 是准实时的，因为写入的数据 1 秒之后才能被看到。可以通过 es 的 "),e("code",[_._v("restful api")]),_._v(" 或者 "),e("code",[_._v("java api")]),_._v("，"),e("strong",[_._v("手动")]),_._v("执行一次 refresh 操作，就是手动将 buffer 中的数据刷入 "),e("code",[_._v("os cache")]),_._v("中，让数据立马就可以被搜索到。只要数据被输入 "),e("code",[_._v("os cache")]),_._v(" 中，buffer 就会被清空了，因为不需要保留 buffer 了，数据在 translog 里面已经持久化到磁盘去一份了。")]),_._v(" "),e("p",[_._v("重复上面的步骤，新的数据不断进入 buffer 和 translog，不断将 "),e("code",[_._v("buffer")]),_._v(" 数据写入一个又一个新的 "),e("code",[_._v("segment file")]),_._v(" 中去，每次 "),e("code",[_._v("refresh")]),_._v(" 完 buffer 清空，translog 保留。随着这个过程推进，translog 会变得越来越大。当 translog 达到一定长度的时候，就会触发 "),e("code",[_._v("commit")]),_._v(" 操作。")]),_._v(" "),e("p",[_._v("commit 操作发生第一步，就是将 buffer 中现有数据 "),e("code",[_._v("refresh")]),_._v(" 到 "),e("code",[_._v("os cache")]),_._v(" 中去，清空 buffer。然后，将一个 "),e("code",[_._v("commit point")]),_._v(" 写入磁盘文件，里面标识着这个 "),e("code",[_._v("commit point")]),_._v(" 对应的所有 "),e("code",[_._v("segment file")]),_._v("，同时强行将 "),e("code",[_._v("os cache")]),_._v(" 中目前所有的数据都 "),e("code",[_._v("fsync")]),_._v(" 到磁盘文件中去。最后"),e("strong",[_._v("清空")]),_._v(" 现有 translog 日志文件，重启一个 translog，此时 commit 操作完成。")]),_._v(" "),e("p",[_._v("这个 commit 操作叫做 "),e("code",[_._v("flush")]),_._v("。默认 30 分钟自动执行一次 "),e("code",[_._v("flush")]),_._v("，但如果 translog 过大，也会触发 "),e("code",[_._v("flush")]),_._v("。flush 操作就对应着 commit 的全过程，我们可以通过 es api，手动执行 flush 操作，手动将 os cache 中的数据 fsync 强刷到磁盘上去。")]),_._v(" "),e("p",[_._v("translog 日志文件的作用是什么？你执行 commit 操作之前，数据要么是停留在 buffer 中，要么是停留在 os cache 中，无论是 buffer 还是 os cache 都是内存，一旦这台机器死了，内存中的数据就全丢了。所以需要将数据对应的操作写入一个专门的日志文件 "),e("code",[_._v("translog")]),_._v(" 中，一旦此时机器宕机，再次重启的时候，es 会自动读取 translog 日志文件中的数据，恢复到内存 buffer 和 os cache 中去。")]),_._v(" "),e("p",[_._v("translog 其实也是先写入 os cache 的，默认每隔 5 秒刷一次到磁盘中去，所以默认情况下，可能有 5 秒的数据会仅仅停留在 buffer 或者 translog 文件的 os cache 中，如果此时机器挂了，会"),e("strong",[_._v("丢失")]),_._v(" 5 秒钟的数据。但是这样性能比较好，最多丢 5 秒的数据。也可以将 translog 设置成每次写操作必须是直接 "),e("code",[_._v("fsync")]),_._v(" 到磁盘，但是性能会差很多。")]),_._v(" "),e("p",[_._v("实际上你在这里，如果面试官没有问你 es 丢数据的问题，你可以在这里给面试官炫一把，你说，其实 es 第一是准实时的，数据写入 1 秒后可以搜索到；可能会丢失数据的。有 5 秒的数据，停留在 buffer、translog os cache、segment file os cache 中，而不在磁盘上，此时如果宕机，会导致 5 秒的"),e("strong",[_._v("数据丢失")]),_._v("。")]),_._v(" "),e("p",[e("strong",[_._v("总结一下")]),_._v("，数据先写入内存 buffer，然后每隔 1s，将数据 refresh 到 os cache，到了 os cache 数据就能被搜索到（所以我们才说 es 从写入到能被搜索到，中间有 1s 的延迟）。每隔 5s，将数据写入 translog 文件（这样如果机器宕机，内存数据全没，最多会有 5s 的数据丢失），translog 大到一定程度，或者默认每隔 30mins，会触发 commit 操作，将缓冲区的数据都 flush 到 segment file 磁盘文件中。")]),_._v(" "),e("blockquote",[e("p",[_._v("数据写入 segment file 之后，同时就建立好了倒排索引。")])]),_._v(" "),e("h3",{attrs:{id:"删除-更新数据底层原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#删除-更新数据底层原理"}},[_._v("#")]),_._v(" 删除/更新数据底层原理")]),_._v(" "),e("p",[_._v("如果是删除操作，commit 的时候会生成一个 "),e("code",[_._v(".del")]),_._v(" 文件，里面将某个 doc 标识为 "),e("code",[_._v("deleted")]),_._v(" 状态，那么搜索的时候根据 "),e("code",[_._v(".del")]),_._v(" 文件就知道这个 doc 是否被删除了。")]),_._v(" "),e("p",[_._v("如果是更新操作，就是将原来的 doc 标识为 "),e("code",[_._v("deleted")]),_._v(" 状态，然后新写入一条数据。")]),_._v(" "),e("p",[_._v("buffer 每 refresh 一次，就会产生一个 "),e("code",[_._v("segment file")]),_._v("，所以默认情况下是 1 秒钟一个 "),e("code",[_._v("segment file")]),_._v("，这样下来 "),e("code",[_._v("segment file")]),_._v(" 会越来越多，此时会定期执行 merge。每次 merge 的时候，会将多个 "),e("code",[_._v("segment file")]),_._v(" 合并成一个，同时这里会将标识为 "),e("code",[_._v("deleted")]),_._v(" 的 doc 给"),e("strong",[_._v("物理删除掉")]),_._v("，然后将新的 "),e("code",[_._v("segment file")]),_._v(" 写入磁盘，这里会写一个 "),e("code",[_._v("commit point")]),_._v("，标识所有新的 "),e("code",[_._v("segment file")]),_._v("，然后打开 "),e("code",[_._v("segment file")]),_._v(" 供搜索使用，同时删除旧的 "),e("code",[_._v("segment file")]),_._v("。")]),_._v(" "),e("h3",{attrs:{id:"_2-2-5-底层-lucene"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-5-底层-lucene"}},[_._v("#")]),_._v(" 2.2.5. 底层 lucene")]),_._v(" "),e("p",[_._v("简单来说，lucene 就是一个 jar 包，里面包含了封装好的各种建立倒排索引的算法代码。我们用 Java 开发的时候，引入 lucene jar，然后基于 lucene 的 api 去开发就可以了。")]),_._v(" "),e("p",[_._v("通过 lucene，我们可以将已有的数据建立索引，lucene 会在本地磁盘上面，给我们组织索引的数据结构。")]),_._v(" "),e("h4",{attrs:{id:"_2-2-6-倒排索引"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-6-倒排索引"}},[_._v("#")]),_._v(" 2.2.6. 倒排索引")]),_._v(" "),e("p",[_._v("在搜索引擎中，每个文档都有一个对应的文档 ID，文档内容被表示为一系列关键词的集合。例如，文档 1 经过分词，提取了 20 个关键词，每个关键词都会记录它在文档中出现的次数和出现位置。")]),_._v(" "),e("p",[_._v("那么，倒排索引就是"),e("strong",[_._v("关键词到文档")]),_._v(" ID 的映射，每个关键词都对应着一系列的文件，这些文件中都出现了关键词。")]),_._v(" "),e("p",[_._v("举个栗子。")]),_._v(" "),e("p",[_._v("有以下文档：")]),_._v(" "),e("table",[e("thead",[e("tr",[e("th",[_._v("DocId")]),_._v(" "),e("th",[_._v("Doc")])])]),_._v(" "),e("tbody",[e("tr",[e("td",[_._v("1")]),_._v(" "),e("td",[_._v("谷歌地图之父跳槽 Facebook")])]),_._v(" "),e("tr",[e("td",[_._v("2")]),_._v(" "),e("td",[_._v("谷歌地图之父加盟 Facebook")])]),_._v(" "),e("tr",[e("td",[_._v("3")]),_._v(" "),e("td",[_._v("谷歌地图创始人拉斯离开谷歌加盟 Facebook")])]),_._v(" "),e("tr",[e("td",[_._v("4")]),_._v(" "),e("td",[_._v("谷歌地图之父跳槽 Facebook 与 Wave 项目取消有关")])]),_._v(" "),e("tr",[e("td",[_._v("5")]),_._v(" "),e("td",[_._v("谷歌地图之父拉斯加盟社交网站 Facebook")])])])]),_._v(" "),e("p",[_._v("对文档进行分词之后，得到以下"),e("strong",[_._v("倒排索引")]),_._v("。")]),_._v(" "),e("table",[e("thead",[e("tr",[e("th",[_._v("WordId")]),_._v(" "),e("th",[_._v("Word")]),_._v(" "),e("th",[_._v("DocIds")])])]),_._v(" "),e("tbody",[e("tr",[e("td",[_._v("1")]),_._v(" "),e("td",[_._v("谷歌")]),_._v(" "),e("td",[_._v("1,2,3,4,5")])]),_._v(" "),e("tr",[e("td",[_._v("2")]),_._v(" "),e("td",[_._v("地图")]),_._v(" "),e("td",[_._v("1,2,3,4,5")])]),_._v(" "),e("tr",[e("td",[_._v("3")]),_._v(" "),e("td",[_._v("之父")]),_._v(" "),e("td",[_._v("1,2,4,5")])]),_._v(" "),e("tr",[e("td",[_._v("4")]),_._v(" "),e("td",[_._v("跳槽")]),_._v(" "),e("td",[_._v("1,4")])]),_._v(" "),e("tr",[e("td",[_._v("5")]),_._v(" "),e("td",[_._v("Facebook")]),_._v(" "),e("td",[_._v("1,2,3,4,5")])]),_._v(" "),e("tr",[e("td",[_._v("6")]),_._v(" "),e("td",[_._v("加盟")]),_._v(" "),e("td",[_._v("2,3,5")])]),_._v(" "),e("tr",[e("td",[_._v("7")]),_._v(" "),e("td",[_._v("创始人")]),_._v(" "),e("td",[_._v("3")])]),_._v(" "),e("tr",[e("td",[_._v("8")]),_._v(" "),e("td",[_._v("拉斯")]),_._v(" "),e("td",[_._v("3,5")])]),_._v(" "),e("tr",[e("td",[_._v("9")]),_._v(" "),e("td",[_._v("离开")]),_._v(" "),e("td",[_._v("3")])]),_._v(" "),e("tr",[e("td",[_._v("10")]),_._v(" "),e("td",[_._v("与")]),_._v(" "),e("td",[_._v("4")])]),_._v(" "),e("tr",[e("td",[_._v("..")]),_._v(" "),e("td",[_._v("..")]),_._v(" "),e("td",[_._v("..")])])])]),_._v(" "),e("p",[_._v("另外，实用的倒排索引还可以记录更多的信息，比如文档频率信息，表示在文档集合中有多少个文档包含某个单词。")]),_._v(" "),e("p",[_._v("那么，有了倒排索引，搜索引擎可以很方便地响应用户的查询。比如用户输入查询 "),e("code",[_._v("Facebook")]),_._v("，搜索系统查找倒排索引，从中读出包含这个单词的文档，这些文档就是提供给用户的搜索结果。")]),_._v(" "),e("p",[_._v("要注意倒排索引的两个重要细节：")]),_._v(" "),e("ul",[e("li",[_._v("倒排索引中的所有词项对应一个或多个文档；")]),_._v(" "),e("li",[_._v("倒排索引中的词项"),e("strong",[_._v("根据字典顺序升序排列")])])]),_._v(" "),e("blockquote",[e("p",[_._v("上面只是一个简单的栗子，并没有严格按照字典顺序升序排列。")])])])}),[],!1,null,null,null);v.default=t.exports}}]);